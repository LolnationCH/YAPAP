# Adapted from http://www.hackerthreads.org/Topic-42395
# TO DElETE

import ctypes
from ctypes import wintypes
import atexit
import traceback

from codes.InputConst import *
from codes.KbdScanCode import *
from KeyboardEvent import KeyboardEvent
from functions import (user32, LPMSG, SetWindowsHookEx, UnhookWindowsHookEx, CallNextHookEx, GetMessage,
                       TranslateMessage, DispatchMessage, GetKeyState, GetModuleHandle, LowLevelKeyboardProc, GetKeyNameText)
                       
ShiftPressed = False 
AltGrPressed = False 
ignoreExtraAltRight = False 
lt_shiftVK = [VK_SHIFT, VK_LSHIFT, VK_RSHIFT]

LLKHF_INJECTED = 0x00000010
WH_KEYBOARD_LL = ctypes.c_int(13)

KEY_DOWN = 'DOWN'
KEY_UP = 'UP'

keyboard_event_types = { 
    WM_KEYDOWN: KEY_DOWN, 
    WM_KEYUP: KEY_UP, 
    WM_SYSKEYDOWN: KEY_DOWN, 
    WM_SYSKEYUP: KEY_UP, 
}

def __hooking_keyboard(callback):    
    def process_key(event_type, vk, scan_code, is_extended):
        global ShiftPressed, AltGrPressed, ignoreExtraAltRight

        # AltGr generates an extra "right alt" event
        if vk == VK_RMENU and ignoreExtraAltRight:
            ignoreExtraAltRight = False
            return True

        modifiersState = {
            'SHIFT'    : ShiftPressed,
            'ALTGR'    : AltGrPressed,
            'NUMLOCK'  : (GetKeyState(0x90) & 1),
            'CAPSLOCK' : (GetKeyState(0x14) & 1),
            'SCRLOCK'  : (GetKeyState(0x91) & 1)
        }
        entry = (scan_code, vk, is_extended, modifiersState)
        
        name = list(GetKeyNameText(vk, scan_code, is_extended, modifiersState))
        if name == None:
            name = hex(vk)

        # TODO: inaccurate when holding multiple different shifts.
        if vk in lt_shiftVK:
            ShiftPressed = event_type == KEY_DOWN

        # Better way handle this has exist
        # on EN-US and CAN-FR, this not seen, further investigation required
        if scan_code == 541 and vk == VK_LCONTROL:
            ignoreExtraAltRight = True
            AltGrPressed = event_type == KEY_DOWN

        is_keypad = (vk in lt_Numpad) or ((scan_code, vk, is_extended) in lt_OtherNumpad)
        event = KeyboardEvent(event_type=event_type, scan_code=scan_code or -vk, name=name, is_keypad=is_keypad)
        return callback(event)

    def low_level_keyboard_handler(nCode, wParam, lParam):
        try:
            vk = lParam.contents.vk_code
            # Ignore the second 'alt' DOWN observed in some cases.
            fake_alt = (LLKHF_INJECTED | 0x20)
            
            # Ignore events generated by SendInput with Unicode.
            if vk != VK_PACKET and lParam.contents.flags & fake_alt != fake_alt:
                event_type = keyboard_event_types[wParam]
                is_extended = lParam.contents.flags & 1
                scan_code = lParam.contents.scan_code
                should_continue = process_key(event_type, vk, scan_code, is_extended)
                if not should_continue:
                    return -1
        except Exception as e:
            print('Error in keyboard hook:')
            traceback.print_exc()

        return CallNextHookEx(None, nCode, wParam, lParam)

    keyboard_callback = LowLevelKeyboardProc(low_level_keyboard_handler)
    handle =  ctypes.c_int(0)
    thread_id = wintypes.DWORD(0)
    keyboard_hook = SetWindowsHookEx(WH_KEYBOARD_LL, keyboard_callback, handle, thread_id)

    atexit.register(UnhookWindowsHookEx, keyboard_callback)

    
        
def listen(callback):
    __hooking_keyboard(callback)
    msg = LPMSG()
    while not GetMessage(msg, 0, 0, 0):
        TranslateMessage(msg)
        DispatchMessage(msg)


if __name__ == '__main__':
    def f(event):
        print(event)
        return True
    listen(f)